# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Development Guidelines

## Project Structure Analysis

Before making any changes or adding new features, always follow these steps:

1. Project Structure Analysis

   ```bash
   # Use list_dir to understand folder structure
   list_dir <path>

   # Use grep_search to find relevant files
   grep_search <pattern>

   # Use read_file to read relevant files
   read_file <path>
   ```

2. Find Similar Implementations

   - Look for files with similar patterns
   - Understand how similar features are implemented
   - Follow the same patterns for consistency

3. Understand Patterns Used

   - Note file and folder structure
   - Note file and class naming
   - Note state management implementation
   - Note routing implementation

4. Follow Same Structure
   - Place files in appropriate folders
   - Use consistent naming
   - Follow existing implementation patterns
   - Don't create new structures unless absolutely necessary

## Development Workflow

### 1. Task Planning

Before starting any task:

1. Review the task requirements
2. Check the Scratchpad for any existing related tasks
3. Clear old tasks if necessary
4. Document the task in the Scratchpad:

   ```
   ## Current Task

   ### Task Description
   [Describe the task]

   ### Project Structure Analysis
   [Document findings from structure analysis]

   ### Similar Implementations
   [List similar implementations found]

   ### Implementation Plan
   [ ] Step 1
   [ ] Step 2
   [ ] Step 3

   ### Progress Tracking
   [ ] Step 1 completed
   [ ] Step 2 completed
   [ ] Step 3 completed
   ```

### 2. Implementation Steps

For each feature or change:

1. Create necessary models
2. Implement repository layer
3. Implement service layer
4. Create provider
5. Build UI components
6. Add routing
7. Test the implementation

### 3. Code Review Checklist

Before submitting changes:

- [ ] Followed project structure
- [ ] Used consistent naming
- [ ] Followed existing patterns
- [ ] Added proper error handling
- [ ] Added loading states
- [ ] Added proper documentation
- [ ] Tested the implementation

## File Structure Guidelines

### 1. Models

- Place in `lib/data/datasource/models/`
- Follow naming: `*_model.dart`
- Include fromJson and toJson methods
- Add proper documentation

### 2. Repositories

- Place in `lib/data/datasource/network/repository/`
- Follow naming: `*_repository.dart`
- Extend BaseRepository
- Handle API calls and data conversion

### 3. Services

- Place in `lib/data/datasource/network/service/`
- Follow naming: `*_service.dart`
- Extend BaseService
- Handle business logic

### 4. Providers

- Place in `lib/presentation/providers/`
- Follow naming: `*_provider.dart`
- Extend BaseProvider
- Handle state management

### 5. Pages

- Place in `lib/presentation/pages/*/`
- Follow naming: `*_page.dart`
- Use ProviderPage for state management
- Follow existing UI patterns

### 6. Widgets

- Place in `lib/presentation/widgets/`
- Follow naming: `*_widget.dart`
- Make reusable components
- Follow existing widget patterns

## UI Guidelines

### 1. Colors

- Use AppColors for all colors
- Follow existing color patterns
- Use proper opacity values

### 2. Typography

- Use AppTypography for all text styles
- Follow existing typography patterns
- Use appropriate font sizes

### 3. Spacing

- Use AppTheme.spacing\* for all spacing
- Follow existing spacing patterns
- Maintain consistent padding and margins

### 4. Components

- Use Mahas widgets when available
- Follow existing component patterns
- Maintain consistent styling

## State Management Guidelines

### 1. Providers

- Use ProviderPage for state management
- Follow existing provider patterns
- Handle loading and error states
- Implement proper data refresh

### 2. Data Flow

- Repository -> Service -> Provider -> UI
- Handle errors at each layer
- Implement proper loading states
- Cache data when appropriate

## Routing Guidelines

### 1. Routes

- Define in AppRoutes
- Follow existing route patterns
- Use proper route names
- Handle deep linking

### 2. Navigation

- Use Mahas.routeTo for navigation
- Pass proper arguments
- Handle navigation errors
- Implement proper back navigation

## Error Handling Guidelines

### 1. API Errors

- Handle network errors
- Handle API response errors
- Show proper error messages
- Implement retry mechanism

### 2. UI Errors

- Handle validation errors
- Show proper error messages
- Implement proper error recovery
- Maintain user state

## Testing Guidelines

### 1. Unit Tests

- Test models
- Test repositories
- Test services
- Test providers

### 2. Widget Tests

- Test UI components
- Test user interactions
- Test error states
- Test loading states

## Documentation Guidelines

### 1. Code Documentation

- Document public methods
- Document complex logic
- Document error handling
- Document state management

### 2. API Documentation

- Document API endpoints
- Document request/response
- Document error codes
- Document rate limits

## Lessons Learned

1. Saat mengimplementasikan model dari API, perhatikan perbedaan antara referensi objek dan objek lengkap.
   Misalnya pada kasus `LocationAreaDetail`, field `location` dalam API hanya berisi referensi (name & url), bukan objek Location lengkap.
   Solusinya: buat class terpisah seperti `LocationReference` untuk menampung referensi ke objek.

## Scratchpad

## Current Task

### Task Description

Memperbaiki fitur location dengan menggunakan ability sebagai referensi untuk memastikan konsistensi implementasi.

### Project Structure Analysis

[X] Analisis struktur folder ability
[X] Analisis struktur folder location
[X] Identifikasi perbedaan implementasi

### Similar Implementations

[X] Cari implementasi ability
[X] Bandingkan dengan implementasi location
[X] Catat pola yang perlu disesuaikan

### Implementation Plan

[X] Perbaiki LocationDetailProvider
[X] Perbaiki LocationDetailPage
[X] Buat LocationAreaDetail (tambahan sesuai permintaan)
[X] Pastikan konsistensi dengan ability

### Progress Tracking

[X] Membaca implementasi ability
[X] Menganalisis perbedaan dengan location
[X] Mengimplementasikan perbaikan
[X] Menambahkan fitur LocationAreaDetail
[X] Review hasil implementasi
