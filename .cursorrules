# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

# Development Guidelines

## Project Structure Analysis

Before making any changes or adding new features, always follow these steps:

1. Project Structure Analysis

```bash
   # Use list_dir to understand folder structure
   list_dir <path>

   # Use grep_search to find relevant files
   grep_search <pattern>

   # Use read_file to read relevant files
   read_file <path>
```

2. Find Similar Implementations

   - Look for files with similar patterns
   - Understand how similar features are implemented
   - Follow the same patterns for consistency

3. Understand Patterns Used

   - Note file and folder structure
   - Note file and class naming
   - Note state management implementation
   - Note routing implementation

4. Follow Same Structure
   - Place files in appropriate folders
   - Use consistent naming
   - Follow existing implementation patterns
   - Don't create new structures unless absolutely necessary

## File Structure Guidelines

### 1. Models

- Place in `lib/data/datasource/models/`
- Follow naming: `*_model.dart`
- Include fromJson and toJson methods
- Add proper documentation

### 2. Repositories

- Place in `lib/data/datasource/network/repository/`
- Follow naming: `*_repository.dart`
- Extend BaseRepository
- Handle API calls and data conversion

### 3. Services

- Place in `lib/data/datasource/network/service/`
- Follow naming: `*_service.dart`
- Extend BaseService
- Handle business logic

### 4. Providers

- Place in `lib/presentation/providers/`
- Follow naming: `*_provider.dart`
- Extend BaseProvider
- Handle state management

### 5. Pages

- Place in `lib/presentation/pages/*/`
- Follow naming: `*_page.dart`
- Use ProviderPage for state management
- Follow existing UI patterns

### 6. Widgets

- Place in `lib/presentation/widgets/`
- Follow naming: `*_widget.dart`
- Make reusable components
- Follow existing widget patterns

## UI Guidelines

### 1. Colors

- Use AppColors for all colors
- Follow existing color patterns
- Use proper opacity values

### 2. Typography

- Use AppTypography for all text styles
- Follow existing typography patterns
- Use appropriate font sizes

### 3. Spacing

- Use AppTheme.spacing\* for all spacing
- Follow existing spacing patterns
- Maintain consistent padding and margins

### 4. Components

- Use Mahas widgets when available
- Follow existing component patterns
- Maintain consistent styling

# Software Development Principles

Here are the software development principles that should be followed:

## 1. KISS (Keep It Simple, Stupid)

- Always choose the simplest solution
- Avoid unnecessary complexity
- If there are two equally effective solutions, choose the simpler one
- Find direct solutions that address the root of the problem

## 2. DRY (Don't Repeat Yourself)

- Avoid code duplication
- Extract recurring code into separate functions/components
- Use inheritance, composition, or abstraction to avoid duplication
- Implement single source of truth: define each concept only once

## 3. YAGNI (You Aren't Gonna Need It)

- Don't implement features just because "they might be needed later"
- Focus on current needs, not on future speculation
- Add complexity only when truly needed
- Avoid over-engineering

## 4. SOLID Principles

### Single Responsibility Principle

- A class/module should have only one reason to change
- Each class should have a single, well-defined responsibility
- Separate code that changes for different reasons

### Open/Closed Principle

- Code should be open for extension but closed for modification
- Use abstraction and inheritance to extend functionality
- Avoid changing existing, stable code

### Liskov Substitution Principle

- Subclasses should be able to replace their parent classes without changing behavior
- Don't alter contracts in inheritance
- Ensure subclasses comply with all requirements of the parent class

### Interface Segregation Principle

- Create small, specific interfaces rather than large, general ones
- Classes shouldn't be forced to implement methods they don't need
- Break large interfaces into smaller, more specific ones

### Dependency Inversion Principle

- Depend on abstractions, not concrete implementations
- High-level modules shouldn't depend on low-level modules
- Use dependency injection to separate dependencies

## 5. Separation of Concerns

- Separate the application into parts that handle distinct aspects
- Use layer architecture (UI, business logic, data)
- Don't mix UI code with business logic

## 6. Fail Fast

- Detect errors as early as possible in the development process
- Validate input at the beginning of the process
- Fail clearly rather than continuing with corrupted data
- Use assertions and defensive programming

## 7. Boy Scout Rule

- "Always leave the code better than you found it"
- Refactor bad code when you see it
- Fix technical debt bit by bit
- Improve test coverage in areas you modify

## 8. Composition Over Inheritance

- It's better to compose objects than use inheritance hierarchies
- Use interfaces and dependency injection
- Avoid deep and complex class hierarchies
- It's easier to replace components than replace hierarchies

## 9. "Make it work, make it right, make it fast"

- First, make code that works
- Second, make code that's clean and correct
- Finally, make code that's fast and efficient
- Don't optimize prematurely

## 10. Single Source of Truth

- Data should be defined and stored in only one place
- Avoid state duplication that can become out of sync
- Derive data from the source of truth to components that need it
- All changes should happen at the single source of truth
